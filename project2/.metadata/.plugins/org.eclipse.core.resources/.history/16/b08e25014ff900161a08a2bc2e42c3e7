/*
 * access_functions.c
 *
 *  Created on: Feb 16, 2017
 *      Author: coltonp
 */

#include "access_functions.h"

node_ptr create(int _queue_id data,node_ptr next)
{
	node_ptr new_node = (node*)malloc(sizeof(node));
    if(new_node == NULL)
    {
        printf("Error creating a new node.\n");
        exit(0);
    }
    new_node->data = data;
    new_node->next = next;

    return new_node;
}
/*
node* prepend(node* head,_queue_id data)
{
    node* new_node = create(data,head);
    head = new_node;
    return head;
}

//void func ( void (*f)(int) );
//void traverse(node* head,void * f)
//{
//    node* cursor = head;
//    while(cursor != NULL)
//    {
//        f(cursor);
//        cursor = cursor->next;
//    }
//}


int count(node *head)
{
    node *cursor = head;
    int c = 0;
    while(cursor != NULL)
    {
        c++;
        cursor = cursor->next;
    }
    return c;
}

node* append(node* head, _queue_id data)
{
    // go to the last node
    node *cursor = head;
    while(cursor->next != NULL)
        cursor = cursor->next;

    // create a new node
    node* new_node =  create(data,NULL);
    cursor->next = new_node;

    return head;
}

node* insert_after(node *head, _queue_id data, node* prev)
{
    //find the prev node, starting from the first node
    node *cursor = head;
    while(cursor != prev)
        cursor = cursor->next;

    if(cursor != NULL)
    {
        node* new_node = create(data,cursor->next);
        cursor->next = new_node;
        return head;
    }
    else
    {
        return NULL;
    }
}

node* search(node* head,_queue_id data)
{

    node *cursor = head;
    while(cursor!=NULL)
    {
        if(cursor->data == data)
            return cursor;
        cursor = cursor->next;
    }
    return NULL;
}

node* remove_any(node* head,node* nd)
{
    // if the node is the first node
    if(nd == head)
    {
        head = remove_front(head);
        return head;
    }

    // if the node is the last node
    if(nd->next == NULL)
    {
        head = remove_back(head);
        return head;
    }

    // if the node is in the middle
    node* cursor = head;
    while(cursor != NULL)
    {
        if(cursor->next = nd)
            break;
        cursor = cursor->next;
    }

    if(cursor != NULL)
    {
        node* tmp = cursor->next;
        cursor->next = tmp->next;
        tmp->next = NULL;
        free(tmp);
    }
    return head;
}
*/

// User Tasks access serial channel for reading
// Returns True if a read spot was available
// Returns false if
bool OpenR(_queue_id stream_no){

	if (OpenRStatus == false) {
		OpenRStatus = true;
		//if (count(read_head) == 0) { read_head = create(read_head,stream_no);}
		//else {read_head = append(read_head,stream_no);}
		return true;
	}
	else {
		return false;
	}
	//
}

// User Task actually gets data from serial channel
bool _getline(char * string){
	return false;
}
// Access serial channel for writing
// Returns true if a write spot was available , else false
_queue_id OpenW(){
	if (OpenWStatus == false) {
		OpenWStatus = true;
		return true;
		}
	else {
		return false;
	}
}
// Actually put a string onto the serial channel
_queue_id _putline(_queue_id qid, char * string){
	return 1;
}
// Revoke read and/or write priveledges
bool Close(queue_id qid){
	OpenRStatus = false;
	OpenWStatus = false;//todo
}
